logging {
  level  = "debug"
  format = "logfmt"
}

livedebugging {
  enabled = false
}


prometheus.scrape "prometheus" {
  targets = [
//    { "__address__" = "prometheus:9090", "job" = "prometheus" },
    { "__address__" = "node-exporter:9100", "job" = "node-exporter" },
    { "__address__" = "cadvisor:8080", "job" = "cadvisor" },
    { "__address__" = "crowdsec:6060", "job" = "crowdsec" },
    { "__address__" = "alloy:12345", "job" = "alloy" },
    { "__address__" = "traefik:8082", "job" = "traefik" },
  ]
  scrape_interval = "15s"
  forward_to      = [prometheus.remote_write.demo.receiver]
}

prometheus.remote_write "demo" {
  endpoint {
    url = "http://prometheus:9090/api/v1/write"
  }
}


local.file_match "logs" {
  path_targets = [
    { __path__ = "/var/log/containers/*.log", "job" = "container-logs" },
    { __path__ = "/var/log/pods/**/*.log", "job" = "pod-logs" },
  ]
}

local.file_match "logsgz" {
  path_targets = [
    { __path__ = "/var/log/containers/*.log.gz", "job" = "container-archived-logs" },
  ]
  sync_period = "300s"
  ignore_older_than = "600s"
}


discovery.docker "linux" {
  host = "unix:///var/run/docker.sock"
  filter {
      name = "name"
      values = ["dokploy-traefik", "traefik"]
    }
}


discovery.relabel "logs_integrations_docker" {
  targets = []

  rule {
    target_label = "job"
    replacement = "integrations/docker"
  }

  rule {
    target_label = "instance"
    replacement = constants.hostname
  }

  rule {
    source_labels = ["__meta_docker_container_name"]
    regex = "/(.*)"
    target_label = "container"
  }

  rule {
    source_labels = ["__meta_docker_container_log_stream"]
    target_label = "stream"
  }
}

loki.source.docker "default" {
  host       = "unix:///var/run/docker.sock"
  targets    = discovery.docker.linux.targets
  relabel_rules = discovery.relabel.logs_integrations_docker.rules
  forward_to = [loki.process.add_geo_tags.receiver]
}


loki.source.file "tmpfiles" {
  targets    = local.file_match.logs.targets
  forward_to = [loki.process.add_geo_tags.receiver]
}

loki.source.file "tmpfilesgz" {
  targets    = local.file_match.logsgz.targets
  forward_to = [loki.process.add_geo_tags.receiver]

  decompression {
    enabled       = true
    initial_delay = "10s"
    format        = "gz"
  }
}

loki.process "add_geo_tags" {
  stage.json {
    expressions = { request = "", ts = "" }
  }

  stage.json {
    source      = "request"
    expressions = { ip = "client_ip" }
  }

  stage.geoip {
    source  = "ip"
    db      = "/usr/share/GeoIP/GeoLite2-City.mmdb"
    db_type = "city"
  }

  stage.labels {
    values = {
      geoip_city_name                      = "",
      geoip_country_name                   = "",
      geoip_country_code                   = "",
      geoip_continent_name                 = "",
      geoip_continent_code                 = "",
      geoip_location_latitude              = "",
      geoip_location_longitude             = "",
      geoip_postal_code                    = "",
      geoip_timezone                       = "",
      geoip_subdivision_name               = "",
      geoip_subdivision_code               = "",
      geoip_autonomous_system_organization = "",
    }
  }

  stage.timestamp {
     source = "ts"
     format = "Unix"
  }

  forward_to = [loki.write.local.receiver]
}


loki.write "local" {
  endpoint {
    url = "http://loki:3100/loki/api/v1/push"
  }
}
